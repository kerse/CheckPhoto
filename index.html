<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Проверка фото • JPEG/HEIC/AVIF + Motion/Live</title>
<style>
  :root{--bg:#0b0f14;--fg:#e9eef4;--mut:#9fb3c8;--card:#131a22;--ok:#27c093;--warn:#f5b301;--bad:#ff6b6b}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:920px;margin:0 auto;padding:20px}
  h1{font-size:20px;margin:0 0 6px}
  p{color:var(--mut);margin:0 0 14px}
  .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.28);margin:12px 0}
  input[type=file]{width:100%;border:1px dashed #3a5068;border-radius:12px;padding:14px;background:rgba(255,255,255,.02);color:var(--fg)}
  .row{display:flex;justify-content:space-between;gap:12px;margin:6px 0}
  .k{color:var(--mut)} .v{font-family:ui-monospace,Menlo,Consolas,monospace}
  .sig{word-break:break-all}
  .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.bad{color:var(--bad)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:720px){.grid{grid-template-columns:1fr 1fr}}
  .btn{display:inline-block;margin-top:8px;padding:10px 14px;border-radius:12px;background:#1e2936;color:#dce7f3;text-decoration:none;border:1px solid #33475f}
  .small{font-size:12px;color:var(--mut)}
  img{max-width:100%;height:auto;border-radius:12px;background:#000}
</style>
</head>
<body>
<div class="wrap">
  <h1>Проверка фото</h1>
  <p>Выберите изображение (камера / медиатека / файлы). Покажем формат по сигнатуре, размеры, HEX и <b>детектор Motion/Live</b>.</p>

  <div class="card">
    <input id="file" type="file" accept="image/*">
    <div class="small">Подсказка: на Android/iOS появится системное меню — можно выбрать «Камера», «Фото», «Файлы».</div>
  </div>

  <div id="out" class="grid" hidden>
    <div class="card">
      <h2 style="margin:0 0 8px">Сводка</h2>
      <div class="row"><span class="k">Имя</span><span id="name" class="v"></span></div>
      <div class="row"><span class="k">Расширение</span><span id="ext" class="v"></span></div>
      <div class="row"><span class="k">MIME (браузер)</span><span id="mime" class="v"></span></div>
      <div class="row"><span class="k">Размер</span><span id="size" class="v"></span></div>
      <div class="row"><span class="k">Пиксели</span><span id="wh" class="v"></span></div>
      <div class="row"><span class="k">Формат по сигнатуре</span><span id="fmt" class="v"></span></div>
      <div class="row"><span class="k">Детектор Motion/Live</span><span id="motion" class="v status"></span></div>
      <details style="margin-top:8px">
        <summary>Первые байты (HEX)</summary>
        <div id="hex" class="sig v" style="margin-top:6px"></div>
      </details>
      <a id="copy" class="btn" href="#">Скопировать отчёт</a>
      <div class="small" style="margin-top:8px">Примечание: для iOS Live Photo видео хранится отдельным MOV-файлом; здесь мы показываем эвристику по XMP/EXIF кадра.</div>
    </div>
    <div class="card">
      <h2 style="margin:0 0 8px">Превью</h2>
      <div id="preview"></div>
    </div>
  </div>
</div>

<script>
const $ = s => document.querySelector(s);
const el = {
  file: $('#file'), out: $('#out'),
  name: $('#name'), ext: $('#ext'), mime: $('#mime'), size: $('#size'),
  wh: $('#wh'), fmt: $('#fmt'), motion: $('#motion'), hex: $('#hex'),
  copy: $('#copy'), preview: $('#preview')
};

el.file.addEventListener('change', async () => {
  const f = el.file.files && el.file.files[0];
  if (!f) return;
  el.out.hidden = false;

  el.name.textContent = f.name || '(без имени)';
  el.ext.textContent  = (f.name.match(/\.(\w+)$/)?.[1] || '(нет)').toLowerCase();
  el.mime.textContent = f.type || '(пусто)';
  el.size.textContent = `${f.size} B ≈ ${(f.size/1024/1024).toFixed(2)} MB`;

  // SIG / HEX
  const head = new Uint8Array(await f.slice(0, 64).arrayBuffer());
  el.hex.textContent = [...head].map(b => b.toString(16).padStart(2,'0')).join(' ');

  // Format by magic
  const sig = detectFormat(head);
  el.fmt.textContent = sig;

  // Preview + dimensions
  el.wh.textContent = '…';
  el.preview.innerHTML = '';
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => { el.wh.textContent = `${img.naturalWidth} × ${img.naturalHeight}px`; el.preview.append(img); URL.revokeObjectURL(url); };
  img.onerror = () => { el.wh.textContent = '(не декодируется в этом WebView)'; URL.revokeObjectURL(url); };
  img.src = url;

  // Motion/Live detection (JPEG XMP scan + simple HEIC heuristic)
  const motion = await detectMotionLike(f);
  el.motion.textContent = motion.label;
  el.motion.className = 'v status ' + motion.level;

  el.copy.onclick = (e) => {
    e.preventDefault();
    const txt = [
      `Имя: ${el.name.textContent}`,
      `Расширение: ${el.ext.textContent}`,
      `MIME: ${el.mime.textContent}`,
      `Размер: ${el.size.textContent}`,
      `Пиксели: ${el.wh.textContent}`,
      `Формат (сигнатура): ${el.fmt.textContent}`,
      `Motion/Live: ${motion.label}`,
      `HEX: ${el.hex.textContent}`
    ].join('\n');
    navigator.clipboard?.writeText(txt).then(()=> el.copy.textContent='Скопировано ✓')
      .catch(()=> alert('Не удалось скопировать'));
    setTimeout(()=> el.copy.textContent='Скопировать отчёт', 1200);
  };
});

// --- helpers ---
function detectFormat(u8){
  const s = (o,l)=>String.fromCharCode(...u8.slice(o,o+l));
  if (u8[0]===0xff && u8[1]===0xd8 && u8[2]===0xff) return 'JPEG';
  if (u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4e && u8[3]===0x47) return 'PNG';
  if (s(0,3)==='GIF') return 'GIF';
  if (s(0,4)==='RIFF' && s(8,4)==='WEBP') return 'WEBP';
  if (s(4,4)==='ftyp'){
    const brand = s(8,4);
    if (['heic','heix','heis','hevc','hevx','mif1','msf1'].includes(brand)) return `HEIC/HEIF (ftyp ${brand})`;
    if (['avif','avis'].includes(brand)) return `AVIF (ftyp ${brand})`;
    return `ISOBMFF (ftyp ${brand})`;
  }
  if (u8[0]===0x42 && u8[1]===0x4d) return 'BMP';
  return 'Неизвестно';
}

// Скан JPEG на XMP: ищем APP1 с префиксом XMP и проверяем ключи GCamera/Apple
async function detectMotionLike(file){
  const mime = (file.type||'').toLowerCase();
  const nameExt = (file.name.match(/\.(\w+)$/)?.[1] || '').toLowerCase();

  // HEIC с Live (эвристика): один файл сам по себе обычно обычный кадр, но пометим "возможен Live"
  if (/heic|heif/.test(mime) || /heic|heif/.test(nameExt)) {
    // Внутри HEIC Live-видео хранится отдельно (обычно .mov), поэтому здесь только предупреждение
    return { label:'HEIC: возможен Live Photo (проверь парную MOV/видео часть)', level:'warn' };
  }

  // Для JPEG попробуем извлечь APP1(XMP)
  const isJpeg = await startsWith(file, [0xff,0xd8,0xff]);
  if (!isJpeg) return { label:'обычное фото (признаков нет)', level:'ok' };

  const xmp = await extractXmpFromJpeg(file, 1024*256); // читаем до 256Кб, хватает для APP1
  if (!xmp) return { label:'обычное фото (XMP не найден)', level:'ok' };

  const x = xmp.toLowerCase();

  // Pixel / Google Motion Photo (наиболее надёжные признаки)
  if (x.includes('gcamera:motionphoto') || x.includes('gcamera:microvideo') || x.includes('microvideooffset')) {
    return { label:'НАЙДЕНО: Motion Photo (Pixel/Android)', level:'bad' };
  }

  // iOS Live Photo (только эвристика по XMP/EXIF строкам)
  if (x.includes('livephoto') || x.includes('contentidentifier') || x.includes('com.apple') || x.includes('apple')) {
    return { label:'Подозрение: iOS Live Photo (видео — отдельный MOV)', level:'warn' };
  }

  return { label:'обычное фото (признаков нет)', level:'ok' };
}

async function startsWith(file, sig){
  const buf = new Uint8Array(await file.slice(0, sig.length).arrayBuffer());
  if (buf.length < sig.length) return false;
  return sig.every((b,i)=>buf[i]===b);
}

// Упрощённый парсер сегментов JPEG для извлечения XMP (APP1 с "http://ns.adobe.com/xap/1.0/")
async function extractXmpFromJpeg(file, maxScanBytes=262144){
  const buf = new Uint8Array(await file.slice(0, maxScanBytes).arrayBuffer());
  let i = 2; // пропускаем SOI (FF D8)
  while (i + 4 <= buf.length && buf[i] === 0xFF) {
    const marker = buf[i+1];
    i += 2;
    if (marker === 0xDA) break; // SOS — дальше пиксели, прекращаем
    const len = (buf[i]<<8) + buf[i+1]; i += 2;
    if (len < 2 || i+len-2 > buf.length) break;
    const segment = buf.slice(i, i+len-2);
    i += (len-2);
    // APP1 (EXIF/XMP)
    if (marker === 0xE1) {
      const pre = new TextDecoder().decode(segment.slice(0, 29));
      if (pre.startsWith('http://ns.adobe.com/xap/1.0/')) {
        // дальше идёт XML XMP
        return new TextDecoder().decode(segment.slice(29));
      }
    }
  }
  return null;
}
</script>
</body>
</html>
