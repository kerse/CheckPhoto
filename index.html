<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Проверка фото • JPEG/HEIC/AVIF + Motion/Live/Progressive</title>
<style>
  :root{--bg:#0b0f14;--fg:#e9eef4;--mut:#9fb3c8;--card:#131a22;--ok:#27c093;--warn:#f5b301;--bad:#ff6b6b}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:920px;margin:0 auto;padding:20px}
  h1{font-size:20px;margin:0 0 6px}
  p{color:var(--mut);margin:0 0 14px}
  .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.28);margin:12px 0}
  input[type=file]{width:100%;border:1px dashed #3a5068;border-radius:12px;padding:14px;background:rgba(255,255,255,.02);color:var(--fg)}
  .row{display:flex;justify-content:space-between;gap:12px;margin:6px 0}
  .k{color:var(--mut)} .v{font-family:ui-monospace,Menlo,Consolas,monospace}
  .sig{word-break:break-all}
  .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.bad{color:var(--bad)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:720px){.grid{grid-template-columns:1fr 1fr}}
  .btn{display:inline-block;margin-top:8px;padding:10px 14px;border-radius:12px;background:#1e2936;color:#dce7f3;text-decoration:none;border:1px solid #33475f}
  .small{font-size:12px;color:var(--mut)}
  img{max-width:100%;height:auto;border-radius:12px;background:#000}
</style>
</head>
<body>
<div class="wrap">
  <h1>Проверка фото</h1>
  <p>Выберите изображение (камера / медиатека / файлы). Покажем формат по сигнатуре, размеры, HEX и <b>детектор Motion/Live/Progressive</b>.</p>

  <div class="card">
    <input id="file" type="file" accept="image/*">
    <div class="small">Совет: в Android/iOS появится меню системы — «Камера», «Фото», «Файлы».</div>
  </div>

  <div id="out" class="grid" hidden>
    <div class="card">
      <h2 style="margin:0 0 8px">Сводка</h2>
      <div class="row"><span class="k">Имя</span><span id="name" class="v"></span></div>
      <div class="row"><span class="k">Расширение</span><span id="ext" class="v"></span></div>
      <div class="row"><span class="k">MIME (браузер)</span><span id="mime" class="v"></span></div>
      <div class="row"><span class="k">Размер</span><span id="size" class="v"></span></div>
      <div class="row"><span class="k">Пиксели</span><span id="wh" class="v"></span></div>
      <div class="row"><span class="k">Формат по сигнатуре</span><span id="fmt" class="v"></span></div>
      <div class="row"><span class="k">JPEG режим</span><span id="jpegMode" class="v"></span></div>
      <div class="row"><span class="k">Motion/Live детектор</span><span id="motion" class="v status"></span></div>
      <div class="row"><span class="k">Аномальный вес</span><span id="weight" class="v status"></span></div>
      <details style="margin-top:8px">
        <summary>Первые байты (HEX)</summary>
        <div id="hex" class="sig v" style="margin-top:6px"></div>
      </details>
      <details style="margin-top:8px">
        <summary>Хвост файла (последние 256 байт, HEX)</summary>
        <div id="tailhex" class="sig v" style="margin-top:6px"></div>
      </details>
      <a id="copy" class="btn" href="#">Скопировать отчёт</a>
      <div class="small" style="margin-top:8px">
        Примечание: у iOS Live Photo видео хранится отдельным MOV; здесь — эвристика по XMP/EXIF/маркеру контейнера.
      </div>
    </div>
    <div class="card">
      <h2 style="margin:0 0 8px">Превью</h2>
      <div id="preview"></div>
    </div>
  </div>
</div>

<script>
const $ = s => document.querySelector(s);
const el = {
  file: $('#file'), out: $('#out'),
  name: $('#name'), ext: $('#ext'), mime: $('#mime'), size: $('#size'),
  wh: $('#wh'), fmt: $('#fmt'), motion: $('#motion'), hex: $('#hex'),
  tailhex: $('#tailhex'), copy: $('#copy'), preview: $('#preview'),
  jpegMode: $('#jpegMode'), weight: $('#weight')
};

el.file.addEventListener('change', async () => {
  const f = el.file.files && el.file.files[0];
  if (!f) return;
  el.out.hidden = false;

  el.name.textContent = f.name || '(без имени)';
  el.ext.textContent  = (f.name.match(/\.(\w+)$/)?.[1] || '(нет)').toLowerCase();
  el.mime.textContent = f.type || '(пусто)';
  el.size.textContent = `${f.size} B ≈ ${(f.size/1024/1024).toFixed(2)} MB`;

  // head/tail
  const head = new Uint8Array(await f.slice(0, 96).arrayBuffer());
  const tailLen = Math.min(256, f.size);
  const tail = new Uint8Array(await f.slice(f.size - tailLen, f.size).arrayBuffer());
  el.hex.textContent = toHex(head);
  el.tailhex.textContent = toHex(tail);

  // format
  const sigLabel = detectFormat(head);
  el.fmt.textContent = sigLabel;

  // preview + dimensions
  el.wh.textContent = '…';
  el.preview.innerHTML = '';
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => { el.wh.textContent = `${img.naturalWidth} × ${img.naturalHeight}px`; el.preview.append(img); URL.revokeObjectURL(url); postSizeChecks(f, img.naturalWidth, img.naturalHeight, head, tail); };
  img.onerror = () => { el.wh.textContent = '(не декодируется в этом WebView)'; URL.revokeObjectURL(url); postSizeChecks(f, 0, 0, head, tail); };

  img.src = url;

  // Motion/Live detection (расширенная)
  const motion = await detectMotionLike(f, head, tail);
  el.motion.textContent = motion.label;
  el.motion.className = 'v status ' + motion.level;

  // JPEG baseline/progressive
  el.jpegMode.textContent = await jpegMode(f, head);
});

function toHex(u8){ return [...u8].map(b=>b.toString(16).padStart(2,'0')).join(' '); }

function detectFormat(u8){
  const s = (o,l)=>String.fromCharCode(...u8.slice(o,o+l));
  if (u8[0]===0xff && u8[1]===0xd8 && u8[2]===0xff) return 'JPEG';
  if (u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4e && u8[3]===0x47) return 'PNG';
  if (s(0,3)==='GIF') return 'GIF';
  if (s(0,4)==='RIFF' && s(8,4)==='WEBP') return 'WEBP';
  if (s(4,4)==='ftyp'){
    const brand = s(8,4);
    if (['heic','heix','heis','hevc','hevx','mif1','msf1'].includes(brand)) return `HEIC/HEIF (ftyp ${brand})`;
    if (['avif','avis'].includes(brand)) return `AVIF (ftyp ${brand})`;
    return `ISOBMFF (ftyp ${brand})`;
  }
  if (u8[0]===0x42 && u8[1]===0x4d) return 'BMP';
  return 'Неизвестно';
}

async function detectMotionLike(file, head, tail){
  const mime = (file.type||'').toLowerCase();
  const ext  = (file.name.match(/\.(\w+)$/)?.[1] || '').toLowerCase();

  // HEIC → возможен Live (видео отдельно)
  if (/heic|heif/.test(mime) || /heic|heif/.test(ext)) {
    return { label:'HEIC: возможен Live Photo (видео — отдельный MOV)', level:'warn' };
  }

  // JPEG: сначала XMP
  if (!(head[0]===0xff && head[1]===0xd8 && head[2]===0xff))
    return { label:'обычное фото (признаков нет)', level:'ok' };

  const xmp = await extractXmpFromJpeg(file, 262144);
  if (xmp) {
    const x = xmp.toLowerCase();
    if (x.includes('gcamera:motionphoto') || x.includes('gcamera:microvideo') || x.includes('microvideooffset')) {
      return { label:'НАЙДЕНО: Motion Photo (Pixel/Android, XMP)', level:'bad' };
    }
    if (x.includes('livephoto') || x.includes('contentidentifier') || x.includes('com.apple') || x.includes('makerapple')) {
      return { label:'Подозрение: iOS Live Photo (признаки в XMP/EXIF)', level:'warn' };
    }
  }

  // Доп. проверка: хвост JPEG содержит MP4-боксы → Motion без XMP
  const tailStr = new TextDecoder().decode(tail);
  const hasMP4Box = /ftyp|moov|mdat|mp4|isom|iso5|heic/i.test(tailStr);
  if (hasMP4Box) {
    return { label:'НАЙДЕНО: Motion-хвост в JPEG (без XMP)', level:'bad' };
  }

  return { label:'обычное фото (признаков нет)', level:'ok' };
}

// Упрощённый парсер сегментов JPEG для XMP
async function extractXmpFromJpeg(file, maxBytes){
  const buf = new Uint8Array(await file.slice(0, maxBytes).arrayBuffer());
  let i = 2; // SOI
  while (i + 4 <= buf.length && buf[i] === 0xFF) {
    const marker = buf[i+1]; i += 2;
    if (marker === 0xDA) break; // SOS
    const len = (buf[i]<<8) + buf[i+1]; i += 2;
    if (len < 2 || i+len-2 > buf.length) break;
    const seg = buf.slice(i, i+len-2);
    i += (len-2);
    if (marker === 0xE1) {
      const pre = new TextDecoder().decode(seg.slice(0, 29));
      if (pre.startsWith('http://ns.adobe.com/xap/1.0/')) {
        return new TextDecoder().decode(seg.slice(29));
      }
    }
  }
  return null;
}

// JPEG baseline/progressive по маркерам SOF0/SOF2
async function jpegMode(file, head){
  const isJpeg = head[0]===0xff && head[1]===0xd8 && head[2]===0xff;
  if (!isJpeg) return '—';
  const buf = new Uint8Array(await file.slice(0, Math.min(512*1024, file.size)).arrayBuffer());
  let i = 2;
  while (i + 4 <= buf.length && buf[i] === 0xFF) {
    const marker = buf[i+1]; i += 2;
    if (marker === 0xDA) break;
    const len = (buf[i]<<8) + buf[i+1]; i += 2;
    if (len < 2 || i+len-2 > buf.length) break;
    if (marker === 0xC0) return 'Baseline (SOF0)';
    if (marker === 0xC2) return 'Progressive (SOF2)';
    i += (len-2);
  }
  return 'Не удалось определить';
}

// Эвристика «аномальный вес» после получения размеров
function postSizeChecks(file, w, h, head, tail){
  if (!w || !h) { el.weight.textContent = 'недоступно (нет размеров)'; el.weight.className='v status warn'; return; }
  // bytes per pixel эвристика: JPEG с качеством 0.85 обычно 0.4–1.2 B/px (зависит от сцены).
  const bpp = file.size / (w*h);
  // Смягчённые пороги:
  let label = `${bpp.toFixed(3)} B/px — норма`;
  let cls = 'ok';
  if (bpp > 1.5) { label = `${bpp.toFixed(3)} B/px — тяжёлый JPEG (возможен Motion/Progressive/пересжатие)`; cls='warn'; }
  if (bpp > 2.5) { label = `${bpp.toFixed(3)} B/px — аномально большой (проверь Motion/хвост MP4)`; cls='bad'; }
  el.weight.textContent = label;
  el.weight.className = 'v status ' + cls;
}

</script>
</body>
</html>
