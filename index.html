<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Проверка фото • JPEG/HEIC/AVIF + Motion/Live/Progressive • Нормализация</title>
<style>
  :root{--bg:#0b0f14;--fg:#e9eef4;--mut:#9fb3c8;--card:#131a22;--ok:#27c093;--warn:#f5b301;--bad:#ff6b6b}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:920px;margin:0 auto;padding:20px}
  h1{font-size:20px;margin:0 0 6px}
  p{color:var(--mut);margin:0 0 14px}
  .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.28);margin:12px 0}
  input[type=file]{width:100%;border:1px dashed #3a5068;border-radius:12px;padding:14px;background:rgba(255,255,255,.02);color:var(--fg)}
  .row{display:flex;justify-content:space-between;gap:12px;margin:6px 0}
  .k{color:var(--mut)} .v{font-family:ui-monospace,Menlo,Consolas,monospace}
  .sig{word-break:break-all}
  .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.bad{color:var(--bad)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:720px){.grid{grid-template-columns:1fr 1fr}}
  .btn{display:inline-block;margin-top:8px;padding:10px 14px;border-radius:12px;background:#1e2936;color:#dce7f3;text-decoration:none;border:1px solid #33475f;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .small{font-size:12px;color:var(--mut)}
  img{max-width:100%;height:auto;border-radius:12px;background:#000}
  .hr{height:1px;background:#223142;margin:12px 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>Проверка фото + Нормализация</h1>
  <p>Выберите изображение (камера / медиатека / файлы). Покажем формат по сигнатуре, размеры, HEX и детектор Motion/Live/Progressive. Можно «Нормализовать → JPEG ≤ 2048px» и скачать.</p>

  <div class="card">
    <input id="file" type="file" accept="image/*">
    <div class="small">Совет: на Android/iOS появится системное меню — «Камера», «Фото», «Файлы».</div>
  </div>

  <div id="out" class="grid" hidden>
    <div class="card">
      <h2 style="margin:0 0 8px">Сводка (оригинал)</h2>
      <div class="row"><span class="k">Имя</span><span id="name" class="v"></span></div>
      <div class="row"><span class="k">Расширение</span><span id="ext" class="v"></span></div>
      <div class="row"><span class="k">MIME (браузер)</span><span id="mime" class="v"></span></div>
      <div class="row"><span class="k">Размер</span><span id="size" class="v"></span></div>
      <div class="row"><span class="k">Пиксели</span><span id="wh" class="v"></span></div>
      <div class="row"><span class="k">Формат по сигнатуре</span><span id="fmt" class="v"></span></div>
      <div class="row"><span class="k">JPEG режим</span><span id="jpegMode" class="v"></span></div>
      <div class="row"><span class="k">Motion/Live детектор</span><span id="motion" class="v status"></span></div>
      <div class="row"><span class="k">Аномальный вес</span><span id="weight" class="v status"></span></div>
      <details style="margin-top:8px">
        <summary>Первые байты (HEX)</summary>
        <div id="hex" class="sig v" style="margin-top:6px"></div>
      </details>
      <details style="margin-top:8px">
        <summary>Хвост файла (последние 256 байт, HEX)</summary>
        <div id="tailhex" class="sig v" style="margin-top:6px"></div>
      </details>
      <div class="hr"></div>
      <button id="normalize" class="btn" disabled>Нормализовать → JPEG ≤ 2048px</button>
      <div class="small">Нормализация: рендер в canvas (сброс EXIF/ориентации/хвостов Motion), JPEG quality 0.85. Если WebView не умеет декодировать исходник (например, HEIC на Android), нормализация на клиенте будет недоступна.</div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 8px">Превью</h2>
      <div id="preview"></div>
      <div id="norm" style="margin-top:16px" hidden>
        <div class="hr"></div>
        <h3 style="margin:0 0 8px">Нормализованный файл</h3>
        <div class="row"><span class="k">Имя</span><span id="n_name" class="v"></span></div>
        <div class="row"><span class="k">MIME</span><span id="n_mime" class="v"></span></div>
        <div class="row"><span class="k">Размер</span><span id="n_size" class="v"></span></div>
        <div class="row"><span class="k">Пиксели</span><span id="n_wh" class="v"></span></div>
        <a id="download" class="btn" download="normalized.jpg">Скачать JPEG</a>
      </div>
    </div>
  </div>
</div>

<script>
const $ = s => document.querySelector(s);
const el = {
  file: $('#file'), out: $('#out'),
  name: $('#name'), ext: $('#ext'), mime: $('#mime'), size: $('#size'),
  wh: $('#wh'), fmt: $('#fmt'), motion: $('#motion'), hex: $('#hex'),
  tailhex: $('#tailhex'), preview: $('#preview'), jpegMode: $('#jpegMode'),
  weight: $('#weight'), normalize: $('#normalize'),
  normBox: $('#norm'), n_name: $('#n_name'), n_mime: $('#n_mime'),
  n_size: $('#n_size'), n_wh: $('#n_wh'), download: $('#download')
};

let lastImageDecoded = false; // сможем ли нормализовать на клиенте

el.file.addEventListener('change', async () => {
  const f = el.file.files && el.file.files[0];
  if (!f) return;
  el.out.hidden = false; el.normBox.hidden = true; lastImageDecoded = false;
  el.normalize.disabled = true;

  el.name.textContent = f.name || '(без имени)';
  el.ext.textContent  = (f.name.match(/\.(\w+)$/)?.[1] || '(нет)').toLowerCase();
  el.mime.textContent = f.type || '(пусто)';
  el.size.textContent = `${f.size} B ≈ ${(f.size/1024/1024).toFixed(2)} MB`;

  const head = new Uint8Array(await f.slice(0, 96).arrayBuffer());
  const tailLen = Math.min(256, f.size);
  const tail = new Uint8Array(await f.slice(f.size - tailLen, f.size).arrayBuffer());
  el.hex.textContent = toHex(head);
  el.tailhex.textContent = toHex(tail);

  const sigLabel = detectFormat(head);
  el.fmt.textContent = sigLabel;

  // Preview + dimensions
  el.wh.textContent = '…';
  el.preview.innerHTML = '';
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    lastImageDecoded = true;
    el.normalize.disabled = false;
    el.wh.textContent = `${img.naturalWidth} × ${img.naturalHeight}px`;
    el.preview.append(img);
    URL.revokeObjectURL(url);
    postSizeChecks(f, img.naturalWidth, img.naturalHeight);
  };
  img.onerror = () => {
    lastImageDecoded = false;
    el.wh.textContent = '(не декодируется в этом WebView — нормализация недоступна)';
    URL.revokeObjectURL(url);
    postSizeChecks(f, 0, 0);
  };
  img.src = url;

  // Motion/Live + JPEG mode
  const motion = await detectMotionLike(f, head, tail);
  el.motion.textContent = motion.label;
  el.motion.className = 'v status ' + motion.level;
  el.jpegMode.textContent = await jpegMode(f, head);
});

// Кнопка нормализации
el.normalize.addEventListener('click', async () => {
  const f = el.file.files && el.file.files[0];
  if (!f) return;
  if (!lastImageDecoded) {
    alert('Исходник не декодируется в этом WebView (например, HEIC на Android). Нормализация на клиенте невозможна — сделайте экспорт в JPEG или нормализуйте на сервере.');
    return;
  }
  const norm = await normalizeToJpeg(f, 2048, 0.85);
  if (!norm) { alert('Не удалось нормализовать файл.'); return; }

  // Показать инфо + превью скачивания
  el.normBox.hidden = false;
  el.n_name.textContent = norm.name;
  el.n_mime.textContent = norm.type;
  el.n_size.textContent = `${norm.size} B ≈ ${(norm.size/1024/1024).toFixed(2)} MB`;

  // размер изображения
  const blobUrl = URL.createObjectURL(norm);
  const img2 = new Image();
  img2.onload = () => {
    el.n_wh.textContent = `${img2.naturalWidth} × ${img2.naturalHeight}px`;
    URL.revokeObjectURL(blobUrl);
  };
  img2.src = blobUrl;

  el.download.href = URL.createObjectURL(norm);
  el.download.download = (f.name || 'image').replace(/\.\w+$/, '') + '.jpg';
});

// ---------- helpers ----------
function toHex(u8){ return [...u8].map(b=>b.toString(16).padStart(2,'0')).join(' '); }

function detectFormat(u8){
  const s = (o,l)=>String.fromCharCode(...u8.slice(o,o+l));
  if (u8[0]===0xff && u8[1]===0xd8 && u8[2]===0xff) return 'JPEG';
  if (u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4e && u8[3]===0x47) return 'PNG';
  if (s(0,3)==='GIF') return 'GIF';
  if (s(0,4)==='RIFF' && s(8,4)==='WEBP') return 'WEBP';
  if (s(4,4)==='ftyp'){
    const brand = s(8,4);
    if (['heic','heix','heis','hevc','hevx','mif1','msf1'].includes(brand)) return `HEIC/HEIF (ftyp ${brand})`;
    if (['avif','avis'].includes(brand)) return `AVIF (ftyp ${brand})`;
    return `ISOBMFF (ftyp ${brand})`;
  }
  if (u8[0]===0x42 && u8[1]===0x4d) return 'BMP';
  return 'Неизвестно';
}

async function detectMotionLike(file, head, tail){
  const mime = (file.type||'').toLowerCase();
  const ext  = (file.name.match(/\.(\w+)$/)?.[1] || '').toLowerCase();

  // HEIC → вероятен Live (видео отдельно)
  if (/heic|heif/.test(mime) || /heic|heif/.test(ext)) {
    return { label:'HEIC: возможен Live Photo (видео — отдельный MOV)', level:'warn' };
  }

  // JPEG: XMP
  if (!(head[0]===0xff && head[1]===0xd8 && head[2]===0xff))
    return { label:'обычное фото (признаков нет)', level:'ok' };

  const xmp = await extractXmpFromJpeg(file, 262144);
  if (xmp) {
    const x = xmp.toLowerCase();
    if (x.includes('gcamera:motionphoto') || x.includes('gcamera:microvideo') || x.includes('microvideooffset')) {
      return { label:'НАЙДЕНО: Motion Photo (Pixel/Android, XMP)', level:'bad' };
    }
    if (x.includes('livephoto') || x.includes('contentidentifier') || x.includes('com.apple') || x.includes('makerapple')) {
      return { label:'Подозрение: iOS Live Photo (признаки в XMP/EXIF)', level:'warn' };
    }
  }

  // Хвост JPEG содержит MP4-боксы → Motion без XMP
  const tailStr = new TextDecoder().decode(tail);
  const hasMP4Box = /ftyp|moov|mdat|mp4|isom|iso5|heic/i.test(tailStr);
  if (hasMP4Box) {
    return { label:'НАЙДЕНО: Motion-хвост в JPEG (без XMP)', level:'bad' };
  }
  return { label:'обычное фото (признаков нет)', level:'ok' };
}

// Извлекаем XMP из JPEG (APP1 с префиксом XMP)
async function extractXmpFromJpeg(file, maxBytes){
  const buf = new Uint8Array(await file.slice(0, maxBytes).arrayBuffer());
  let i = 2; // SOI
  while (i + 4 <= buf.length && buf[i] === 0xFF) {
    const marker = buf[i+1]; i += 2;
    if (marker === 0xDA) break; // SOS
    const len = (buf[i]<<8) + buf[i+1]; i += 2;
    if (len < 2 || i+len-2 > buf.length) break;
    const seg = buf.slice(i, i+len-2);
    i += (len-2);
    if (marker === 0xE1) {
      const pre = new TextDecoder().decode(seg.slice(0, 29));
      if (pre.startsWith('http://ns.adobe.com/xap/1.0/')) {
        return new TextDecoder().decode(seg.slice(29));
      }
    }
  }
  return null;
}

// Определяем baseline/progressive по SOF-маркерам
async function jpegMode(file, head){
  const isJpeg = head[0]===0xff && head[1]===0xd8 && head[2]===0xff;
  if (!isJpeg) return '—';
  const buf = new Uint8Array(await file.slice(0, Math.min(512*1024, file.size)).arrayBuffer());
  let i = 2;
  while (i + 4 <= buf.length && buf[i] === 0xFF) {
    const marker = buf[i+1]; i += 2;
    if (marker === 0xDA) break;
    const len = (buf[i]<<8) + buf[i+1]; i += 2;
    if (len < 2 || i+len-2 > buf.length) break;
    if (marker === 0xC0) return 'Baseline (SOF0)';
    if (marker === 0xC2) return 'Progressive (SOF2)';
    i += (len-2);
  }
  return 'Не удалось определить';
}

// Эвристика «аномальный вес» после получения размеров
function postSizeChecks(file, w, h){
  if (!w || !h) { el.weight.textContent = 'недоступно (нет размеров)'; el.weight.className='v status warn'; return; }
  const bpp = file.size / (w*h);
  let label = `${bpp.toFixed(3)} B/px — норма`; let cls = 'ok';
  if (bpp > 1.5) { label = `${bpp.toFixed(3)} B/px — тяжёлый JPEG (возможен Motion/Progressive/пересжатие)`; cls='warn'; }
  if (bpp > 2.5) { label = `${bpp.toFixed(3)} B/px — аномально большой (проверь Motion/хвост MP4)`; cls='bad'; }
  el.weight.textContent = label; el.weight.className = 'v status ' + cls;
}

// Нормализация: canvas → JPEG (≤ maxSide, quality)
async function normalizeToJpeg(file, maxSide=2048, quality=0.85){
  return new Promise((resolve) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      // масштаб
      let {naturalWidth:w, naturalHeight:h} = img;
      const scale = Math.min(1, maxSide / Math.max(w,h));
      const W = Math.max(1, Math.round(w * scale));
      const H = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement('canvas');
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, W, H);

      canvas.toBlob((blob) => {
        URL.revokeObjectURL(url);
        if (!blob) return resolve(null);
        const out = new File([blob], (file.name || 'image').replace(/\.\w+$/, '') + '.jpg', { type: 'image/jpeg' });
        resolve(out);
      }, 'image/jpeg', quality);
    };
    img.onerror = () => { URL.revokeObjectURL(url); resolve(null); };
    img.src = url;
  });
}
</script>
</body>
</html>
